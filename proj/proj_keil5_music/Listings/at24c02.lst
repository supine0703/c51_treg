C51 COMPILER V9.60.7.0   AT24C02                                                           12/05/2023 21:24:39 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE AT24C02
OBJECT MODULE PLACED IN .\Objects\at24c02.obj
COMPILER INVOKED BY: D:\install\Keil_v5\C51\BIN\C51.EXE ..\src\at24c02.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\include;..\i
                    -nclude;D:\install\Keil_v5\C51\INC;..\src) DEBUG OBJECTEXTEND PRINT(.\Listings\at24c02.lst) TABS(2) OBJECT(.\Objects\at24
                    -c02.obj)

line level    source

   1          /**
   2           * ä½œè€…ï¼šæŽå®—éœ– æ—¥æœŸï¼š2023/12/04
   3           * CSDNæ˜µç§°ï¼šLeisure_æ°´ä¸­é±¼
   4           * CSDN: https://blog.csdn.net/Supine_0?type=blog
   5           * ----------------------------------------------
   6           * æ³¨æ„: 24c02çš„æ“ä½œæ˜¯åŸºäºŽI2Cæ“ä½œçš„ æ‰€ä»¥å¯¹å…¶ä¸ºå¼ºä¾èµ– 'i2c.h'
   7           */
   8          #include "i2c.h"
   9          
  10          #ifndef uchar
  11          #define uchar unsigned char
  12          #endif
  13          
  14          // #define PAGE_BYTE 0x08 // ä¹Ÿç¼“å†²å™¨å­—èŠ‚æ•°
  15          
  16          // è¿žç»­è¯»æ—¶åº
  17          bit At24c02_ReadData(uchar sla, uchar suba, uchar* dat, uchar num)
  18          {
  19   1          bit flg;
  20   1          uchar i;
  21   1          if (!num)
  22   1              return 1;
  23   1          I2C_Start();       // å¯åŠ¨I2Cæ€»çº¿
  24   1          I2C_SendByte(sla); // å‘é€å™¨ä»¶åœ°å€ç 
  25   1          if (flg = I2C_CheckAck())
  26   1          {
  27   2              I2C_SendByte(suba); // å‘é€æœŸé—´å•å…ƒåœ°å€
  28   2              if (flg = I2C_CheckAck())
  29   2              {
  30   3                  I2C_Start();           // é‡æ–°å¯åŠ¨I2Cæ€»çº¿
  31   3                  I2C_SendByte(sla + 1); // å‘é€å†™å™¨ä»¶åœ°å€ç ä¿¡å·
  32   3                  if (flg = I2C_CheckAck())
  33   3                  {
  34   4                      for (i = num - 1; i; --i)
  35   4                      {
  36   5                          *dat = I2C_RecByte();
  37   5                          I2C_Ack();
  38   5                          ++dat;
  39   5                      }
  40   4                      *dat = I2C_RecByte();
  41   4                      I2C_NoAck();
  42   4                  }
  43   3              }
  44   2          }
  45   1          I2C_Stop();
  46   1          return flg;
  47   1      }
  48          
  49          // é¡µå†™å…¥æ—¶åº æœ€å¤šä¸º é¡µå†™ç¼“å†²å™¨çš„å¤§å° å­—èŠ‚ è¶…å‡ºä¼šè¢«å¾ªçŽ¯è¦†ç›– ä¸”æ­¤å‡½æ•°ä¸å¸¦å»
             -¶è¿Ÿ
  50          bit At24c02_WriteByte(uchar sla, uchar suba, uchar* dat, uchar num)
  51          {
  52   1          bit flg;
C51 COMPILER V9.60.7.0   AT24C02                                                           12/05/2023 21:24:39 PAGE 2   

  53   1          uchar i;
  54   1          if (!num)
  55   1              return 1;
  56   1          I2C_Start();       // å¯åŠ¨I2Cæ€»çº¿
  57   1          I2C_SendByte(sla); // å‘é€å™¨ä»¶åœ°å€ç 
  58   1          if (flg = I2C_CheckAck())
  59   1          {
  60   2              I2C_SendByte(suba); // å‘é€æœŸé—´å•å…ƒåœ°å€
  61   2              if (flg = I2C_CheckAck())
  62   2              {
  63   3                  for (i = num; i; --i)
  64   3                  {
  65   4                      I2C_SendByte(*dat);
  66   4                      if (!(flg = I2C_CheckAck()))
  67   4                          break; // æ— åº”ç­”
  68   4                      ++dat;
  69   4                  }
  70   3              }
  71   2          }
  72   1          I2C_Stop(); // å‘é€ç»“æŸä¿¡å·
  73   1          return flg;
  74   1      }
  75          
  76          void At24c02_Wait(void) // 12MHz 1000us
  77          {
  78   1          uchar t = 164;
  79   1          while (t--)
  80   1              ;
  81   1          for (t = 2; t; --t)
  82   1              ;
  83   1      }
  84          
  85          bit At24c02_Check(uchar sla) // æ£€æŸ¥æ˜¯å¦å†™å…¥å®Œæˆ
  86          {
  87   1          uchar i = 16;
  88   1          do // æ¯æ¯«ç§’æ£€æµ‹ä¸€æ¬¡å¦‚æžœ 16 æ¬¡æœªåº”ç­”åˆ™æ˜¯ä¸ºé”™è¯¯
  89   1          {
  90   2              At24c02_Wait();
  91   2              I2C_Start();
  92   2              I2C_SendByte(sla); // å‘é€å™¨ä»¶åœ°å€ç 
  93   2          } while (!I2C_CheckAck() && --i);
  94   1          I2C_Stop();
  95   1          return (i != 0);
  96   1      }
  97          
  98          // è¿žç»­é¡µå†™å…¥ å¸¦å»¶è¿Ÿ(ç¡®ä¿å†™å…¥å®Œæˆ)
  99          // bit At24c02_WriteData(uchar sla, uchar suba, uchar* dat, uchar num)
 100          // {
 101          //     while (num > PAGE_BYTE) // æŒ‰é¡µå†™å…¥æ•°æ® å¹¶ä¸”ç­‰å¾…å†™å…¥æˆåŠŸå¼€å§‹ä¸‹ä¸€é¡µå†™å…¥
 102          //     {
 103          //         if (!At24c02_WriteByte(sla, suba, dat, PAGE_BYTE))
 104          //             return 0;
 105          //         suba += PAGE_BYTE;
 106          //         dat += PAGE_BYTE;
 107          //         num -= PAGE_BYTE;
 108          //         if (!At24c02_Check(sla))
 109          //             return 0;
 110          //     }
 111          //     if (At24c02_WriteByte(sla, suba, dat, num))
 112          //         return At24c02_Check(sla);
 113          //     else
 114          //         return 0;
C51 COMPILER V9.60.7.0   AT24C02                                                           12/05/2023 21:24:39 PAGE 3   

 115          // }
 116          
 117          /**
 118           * 2023/12/04
 119           * æœ€å¼€å§‹å­¦24c02æˆ‘ä»¥ä¸ºé¡µå†™å…¥æ“ä½œæ˜¯å­˜å‚¨ç©ºé—´è¢«ä¾‹å¦‚ åˆ’åˆ†ä¸ºäº† æ¯é¡µ16byte å…±16page
 120           * æˆ‘ä»¥ä¸ºæ˜¯åªèƒ½ä»¥æ¯é¡µä¸ºå•ä½è¿›è¡Œå­˜å‚¨ ä¾‹å¦‚ 0x03 å¼€å§‹å­˜å‚¨åˆ°0x0fä¼šè‡ªåŠ¨è¿”å›žåˆ°0x00
 121           * å› ä¸ºè®¸å¤šäººä½¿ç”¨ 'ä¸ä¼šè‡ªåŠ¨ç¿»é¡µ' æ¥å½¢å®¹é¡µå†™å…¥ ç”šè‡³æœ‰äººè®¤ä¸ºæœ‰ 'é¡µè¯»å–'
 122           * è¿™æ˜¯éžå¸¸ç¦»è°±çš„è¯¯ä¼š ä¸‹é¢æœ‰æˆ‘å®žçŽ°çš„ 'é”™è¯¯' çš„è¿žç»­é¡µå†™å…¥æ–¹å¼
 123          å®žçŽ°æ–¹æ³•å¾ˆæœ‰å‚è€ƒä»·å€¼
 124           * æ•…æ­¤ä¿ç•™ å‚è§24c02çš„æ•°æ®æ‰‹å†Œå¯çŸ¥ éœ€è¦é¡µå†™å…¥æ—¶å› ä¸ºå—é™äºŽ é¡µå†™ç¼“å†²å™¨çš„å¤§å°
             -
 125          
 126          
 127          
 128          bit I2C_WriteData(uchar sla, uchar suba, uchar* dat, uchar num)
 129          {
 130              bit flg;
 131              uchar i;
 132              if (!num)
 133                  return 1;
 134              I2C_Start();       // å¯åŠ¨I2Cæ€»çº¿
 135              I2C_SendByte(sla); // å‘é€å™¨ä»¶åœ°å€ç 
 136              if (flg = I2C_CheckAck())
 137              {
 138                  I2C_SendByte(suba); // å‘é€æœŸé—´å•å…ƒåœ°å€
 139                  if (flg = I2C_CheckAck())
 140                  {
 141                      for (i = num; i; --i)
 142                      {
 143                          I2C_SendByte(*dat);
 144                          if (!(flg = I2C_CheckAck()))
 145                              break; // æ— åº”ç­”
 146                          ++dat;
 147                      }
 148                  }
 149              }
 150              I2C_Stop(); // å‘é€ç»“æŸä¿¡å·
 151              return flg;
 152          }
 153          
 154          */
 155          
 156          #define PAGE_BYTE 0x10
 157          #define PAGE_BIT 4
 158          #define PAGE_END 0x0f
 159          
 160          bit At24c02_WriteData(uchar sla, uchar suba, uchar* dat, uchar num)
 161          {
 162   1          uchar begin, end, i;
 163   1          if (!num)
 164   1              return 1;
 165   1          begin = suba >> PAGE_BIT;
 166   1          end = (suba + (num - 1)) >> PAGE_BIT;
 167   1          if (begin != end)
 168   1          {
 169   2              i = PAGE_END - (suba & PAGE_END) + 1;
 170   2              At24c02_WriteByte(sla, suba, dat, i);
 171   2              suba += i;
 172   2              dat += i;
 173   2              ++begin;
 174   2              At24c02_Check(sla);
 175   2          }
C51 COMPILER V9.60.7.0   AT24C02                                                           12/05/2023 21:24:39 PAGE 4   

 176   1          while ((begin != end) && begin < PAGE_END)
 177   1          {
 178   2              At24c02_WriteByte(sla, suba, dat, PAGE_BYTE);
 179   2              suba += PAGE_BYTE;
 180   2              dat += PAGE_BYTE;
 181   2              ++begin;
 182   2              At24c02_Check(sla);
 183   2          }
 184   1          At24c02_WriteByte(
 185   1              sla, suba, dat, (begin == end ? (num - i) & PAGE_END : PAGE_END)
 186   1          );
 187   1          At24c02_Check(sla);
 188   1          return 1;
 189   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    441    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
