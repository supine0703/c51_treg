C51 COMPILER V9.60.7.0   AT24C02                                                           12/05/2023 15:42:12 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE AT24C02
OBJECT MODULE PLACED IN .\Objects\at24c02.obj
COMPILER INVOKED BY: D:\install\Keil_v5\C51\BIN\C51.EXE ..\src\at24c02.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\include) DEB
                    -UG OBJECTEXTEND PRINT(.\Listings\at24c02.lst) TABS(2) OBJECT(.\Objects\at24c02.obj)

line level    source

   1          /**
   2           * ä½œè€…ï¼šæŽå®—éœ– æ—¥æœŸï¼š2023/12/04
   3           * CSDNæ˜µç§°ï¼šLeisure_æ°´ä¸­é±¼
   4           * CSDN: https://blog.csdn.net/Supine_0?type=blog
   5           * ----------------------------------------------
   6           * æ³¨æ„: 24c02çš„æ“ä½œæ˜¯åŸºäºŽI2Cæ“ä½œçš„ æ‰€ä»¥å¯¹å…¶ä¸ºå¼ºä¾èµ– 'i2c.h'
   7           */
   8          #include "i2c.h"
   9          
  10          #ifndef uchar
  11          #define uchar unsigned char
  12          #endif
  13          
  14          #define PAGE_BYTE 0x10 // ä¹Ÿç¼“å†²å™¨å­—èŠ‚æ•°
  15          
  16          // è¿žç»­è¯»æ—¶åº
  17          bit At24c02_ReadData(uchar sla, uchar suba, uchar* dat, uchar num)
  18          {
  19   1          bit flg;
  20   1          uchar i;
  21   1          if (!num)
  22   1              return 1;
  23   1          I2C_Start();       // å¯åŠ¨I2Cæ€»çº¿
  24   1          I2C_SendByte(sla); // å‘é€å™¨ä»¶åœ°å€ç 
  25   1          if (flg = I2C_CheckAck())
  26   1          {
  27   2              I2C_SendByte(suba); // å‘é€æœŸé—´å•å…ƒåœ°å€
  28   2              if (flg = I2C_CheckAck())
  29   2              {
  30   3                  I2C_Start();           // é‡æ–°å¯åŠ¨I2Cæ€»çº¿
  31   3                  I2C_SendByte(sla + 1); // å‘é€å†™å™¨ä»¶åœ°å€ç ä¿¡å·
  32   3                  if (flg = I2C_CheckAck())
  33   3                  {
  34   4                      for (i = num - 1; i; --i)
  35   4                      {
  36   5                          *dat = I2C_RecByte();
  37   5                          I2C_Ack();
  38   5                          ++dat;
  39   5                      }
  40   4                      *dat = I2C_RecByte();
  41   4                      I2C_NoAck();
  42   4                  }
  43   3              }
  44   2          }
  45   1          I2C_Stop();
  46   1          return flg;
  47   1      }
  48          
  49          // é¡µå†™å…¥æ—¶åº æœ€å¤šä¸º é¡µå†™ç¼“å†²å™¨çš„å¤§å° å­—èŠ‚ è¶…å‡ºä¼šè¢«å¾ªçŽ¯è¦†ç›– ä¸”æ­¤å‡½æ•°ä¸å¸¦å»
             -¶è¿Ÿ
  50          bit At24c02_WriteByte(uchar sla, uchar suba, uchar* dat, uchar num)
  51          {
  52   1          bit flg;
  53   1          uchar i;
C51 COMPILER V9.60.7.0   AT24C02                                                           12/05/2023 15:42:12 PAGE 2   

  54   1          if (!num)
  55   1              return 1;
  56   1          I2C_Start();       // å¯åŠ¨I2Cæ€»çº¿
  57   1          I2C_SendByte(sla); // å‘é€å™¨ä»¶åœ°å€ç 
  58   1          if (flg = I2C_CheckAck())
  59   1          {
  60   2              I2C_SendByte(suba); // å‘é€æœŸé—´å•å…ƒåœ°å€
  61   2              if (flg = I2C_CheckAck())
  62   2              {
  63   3                  for (i = num; i; --i)
  64   3                  {
  65   4                      I2C_SendByte(*dat);
  66   4                      if (!(flg = I2C_CheckAck()))
  67   4                          break; // æ— åº”ç­”
  68   4                      ++dat;
  69   4                  }
  70   3              }
  71   2          }
  72   1          I2C_Stop(); // å‘é€ç»“æŸä¿¡å·
  73   1          return flg;
  74   1      }
  75          
  76          void At24c02_Wait(void) // 12MHz 1000us
  77          {
  78   1          uchar t = 164;
  79   1          while (t--)
  80   1              ;
  81   1          for (t = 2; t; --t)
  82   1              ;
  83   1      }
  84          
  85          bit At24c02_Check(uchar sla) // æ£€æŸ¥æ˜¯å¦å†™å…¥å®Œæˆ
  86          {
  87   1          uchar i = 16;
  88   1          do // æ¯æ¯«ç§’æ£€æµ‹ä¸€æ¬¡å¦‚æžœ 16 æ¬¡æœªåº”ç­”åˆ™æ˜¯ä¸ºé”™è¯¯
  89   1          {
  90   2              At24c02_Wait();
  91   2              I2C_Start();
  92   2              I2C_SendByte(sla); // å‘é€å™¨ä»¶åœ°å€ç 
  93   2          } while (!I2C_CheckAck() && --i);
  94   1          I2C_Stop();
  95   1          return (i != 0);
  96   1      }
  97          
  98          // è¿žç»­é¡µå†™å…¥ å¸¦å»¶è¿Ÿ(ç¡®ä¿å†™å…¥å®Œæˆ)
  99          bit At24c02_WriteData(uchar sla, uchar suba, uchar* dat, uchar num)
 100          {
 101   1          while (num > PAGE_BYTE) // æŒ‰é¡µå†™å…¥æ•°æ® å¹¶ä¸”ç­‰å¾…å†™å…¥æˆåŠŸå¼€å§‹ä¸‹ä¸€é¡µå†™å…¥
 102   1          {
 103   2              if (!At24c02_WriteByte(sla, suba, dat, PAGE_BYTE))
 104   2                  return 0;
 105   2              suba += PAGE_BYTE;
 106   2              dat += PAGE_BYTE;
 107   2              num -= PAGE_BYTE;
 108   2              if (!At24c02_Check(sla))
 109   2                  return 0;
 110   2          }
 111   1          if (At24c02_WriteByte(sla, suba, dat, num))
 112   1              return At24c02_Check(sla);
 113   1          else
 114   1              return 0;
 115   1      }
C51 COMPILER V9.60.7.0   AT24C02                                                           12/05/2023 15:42:12 PAGE 3   

 116          
 117          /**
 118           * 2023/12/04
 119           * æœ€å¼€å§‹å­¦24c02æˆ‘ä»¥ä¸ºé¡µå†™å…¥æ“ä½œæ˜¯å­˜å‚¨ç©ºé—´è¢«ä¾‹å¦‚ åˆ’åˆ†ä¸ºäº† æ¯é¡µ16byte å…±16page
 120           * æˆ‘ä»¥ä¸ºæ˜¯åªèƒ½ä»¥æ¯é¡µä¸ºå•ä½è¿›è¡Œå­˜å‚¨ ä¾‹å¦‚ 0x03 å¼€å§‹å­˜å‚¨åˆ°0x0fä¼šè‡ªåŠ¨è¿”å›žåˆ°0x00
 121           * å› ä¸ºè®¸å¤šäººä½¿ç”¨ 'ä¸ä¼šè‡ªåŠ¨ç¿»é¡µ' æ¥å½¢å®¹é¡µå†™å…¥ ç”šè‡³æœ‰äººè®¤ä¸ºæœ‰ 'é¡µè¯»å–'
 122           * è¿™æ˜¯éžå¸¸ç¦»è°±çš„è¯¯ä¼š ä¸‹é¢æœ‰æˆ‘å®žçŽ°çš„ 'é”™è¯¯' çš„è¿žç»­é¡µå†™å…¥æ–¹å¼
 123          å®žçŽ°æ–¹æ³•å¾ˆæœ‰å‚è€ƒä»·å€¼
 124           * æ•…æ­¤ä¿ç•™ å‚è§24c02çš„æ•°æ®æ‰‹å†Œå¯çŸ¥ éœ€è¦é¡µå†™å…¥æ—¶å› ä¸ºå—é™äºŽ é¡µå†™ç¼“å†²å™¨çš„å¤§å°
             -
 125          
 126          #define PAGE_BYTE 0x10
 127          #define PAGE_BIT 4
 128          #define PAGE_END 0x0f
 129          
 130          bit I2C_WriteData(uchar sla, uchar suba, uchar* dat, uchar num)
 131          {
 132              bit flg;
 133              uchar i;
 134              if (!num)
 135                  return 1;
 136              I2C_Start();       // å¯åŠ¨I2Cæ€»çº¿
 137              I2C_SendByte(sla); // å‘é€å™¨ä»¶åœ°å€ç 
 138              if (flg = I2C_CheckAck())
 139              {
 140                  I2C_SendByte(suba); // å‘é€æœŸé—´å•å…ƒåœ°å€
 141                  if (flg = I2C_CheckAck())
 142                  {
 143                      for (i = num; i; --i)
 144                      {
 145                          I2C_SendByte(*dat);
 146                          if (!(flg = I2C_CheckAck()))
 147                              break; // æ— åº”ç­”
 148                          ++dat;
 149                      }
 150                  }
 151              }
 152              I2C_Stop(); // å‘é€ç»“æŸä¿¡å·
 153              return flg;
 154          }
 155          
 156          void At24c02_Write(uchar sla, uchar suba, uchar* dat, uchar num)
 157          {
 158              uchar begin, end, i;
 159              if (!num)
 160                  return;
 161              begin = suba >> PAGE_BIT;
 162              end = (suba + (num - 1)) >> PAGE_BIT;
 163              if (begin != end)
 164              {
 165                  i = PAGE_END - (suba & PAGE_END) + 1;
 166                  I2C_WriteData(sla, suba, dat, i);
 167                  suba += i;
 168                  dat += i;
 169                  ++begin;
 170                  At24c02_Wait();
 171              }
 172              while ((begin != end) && begin < PAGE_END)
 173              {
 174                  I2C_WriteData(sla, suba, dat, PAGE_BYTE);
 175                  suba += PAGE_BYTE;
 176                  dat += PAGE_BYTE;
C51 COMPILER V9.60.7.0   AT24C02                                                           12/05/2023 15:42:12 PAGE 4   

 177                  ++begin;
 178                  At24c02_Wait();
 179              }
 180              I2C_WriteData(
 181                  sla, suba, dat, (begin == end ? (num - i) & PAGE_END : PAGE_END)
 182              );
 183              At24c02_Wait();
 184          }
 185          
 186          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    353    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      22
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
